package metrics

import (
	"fmt"
	"io"
	"runtime"
	"runtime/metrics"
	"sync/atomic"
	"time"

	"github.com/hectorm/cardea/internal/config"
)

var startTime = time.Now()

type Metrics struct {
	ConnectionsActive                   atomic.Int64
	ConnectionsTotal                    atomic.Uint64
	SessionsActive                      atomic.Int64
	SessionsTotal                       atomic.Uint64
	PortForwardsLocalActive             atomic.Int64
	PortForwardsLocalTotal              atomic.Uint64
	PortForwardsRemoteActive            atomic.Int64
	PortForwardsRemoteTotal             atomic.Uint64
	ReceivedBytesTotal                  atomic.Uint64
	SentBytesTotal                      atomic.Uint64
	AuthSuccessesTotal                  atomic.Uint64
	AuthFailuresUnknownKeyTotal         atomic.Uint64
	AuthFailuresNotYetValidKeyTotal     atomic.Uint64
	AuthFailuresNoLongerValidKeyTotal   atomic.Uint64
	AuthFailuresDeniedSourceTotal       atomic.Uint64
	AuthFailuresDeniedBackendTotal      atomic.Uint64
	AuthFailuresInvalidBackendTotal     atomic.Uint64
	RateLimitRejectionsTotal            atomic.Uint64
	BackendErrorsTimeoutTotal           atomic.Uint64
	BackendErrorsRefusedTotal           atomic.Uint64
	BackendErrorsFailedAuthTotal        atomic.Uint64
	BackendErrorsUnknownHostTotal       atomic.Uint64
	BackendErrorsMismatchedHostkeyTotal atomic.Uint64
	BackendErrorsOtherTotal             atomic.Uint64
}

func NewMetrics() *Metrics {
	return &Metrics{}
}

type errWriter struct {
	w   io.Writer
	err error
}

func (ew *errWriter) printf(format string, args ...any) {
	if ew.err != nil {
		return
	}
	_, ew.err = fmt.Fprintf(ew.w, format, args...)
}

func (m *Metrics) WritePrometheus(w io.Writer) error {
	ew := &errWriter{w: w}

	m.writeGoMetrics(ew)
	m.writeCardeaMetrics(ew)
	ew.printf("# EOF\n")

	return ew.err
}

func (m *Metrics) writeGoMetrics(ew *errWriter) {
	threads, _ := runtime.ThreadCreateProfile(nil)

	rms := []metrics.Sample{
		{Name: "/gc/cycles/automatic:gc-cycles"},
		{Name: "/gc/cycles/forced:gc-cycles"},
		{Name: "/gc/cycles/total:gc-cycles"},
		{Name: "/gc/gogc:percent"},
		{Name: "/gc/gomemlimit:bytes"},
		{Name: "/gc/heap/live:bytes"},
		{Name: "/gc/heap/tiny/allocs:objects"},
		{Name: "/gc/limiter/last-enabled:gc-cycle"},
		{Name: "/gc/scan/globals:bytes"},
		{Name: "/gc/scan/heap:bytes"},
		{Name: "/gc/scan/stack:bytes"},
		{Name: "/gc/scan/total:bytes"},
		{Name: "/gc/stack/starting-size:bytes"},
		{Name: "/sync/mutex/wait/total:seconds"},
	}
	metrics.Read(rms)
	rm := make(map[string]metrics.Value, len(rms))
	for _, s := range rms {
		rm[s.Name] = s.Value
	}

	ew.printf("# TYPE go_info gauge\n")
	ew.printf("# HELP go_info Information about the Go environment.\n")
	ew.printf("go_info{version=%q} 1\n", runtime.Version())

	ew.printf("# TYPE go_goroutines gauge\n")
	ew.printf("# HELP go_goroutines Number of goroutines that currently exist.\n")
	ew.printf("go_goroutines %d\n", runtime.NumGoroutine())

	ew.printf("# TYPE go_threads gauge\n")
	ew.printf("# HELP go_threads Number of OS threads created.\n")
	ew.printf("go_threads %d\n", threads)

	ew.printf("# TYPE go_sched_gomaxprocs_threads gauge\n")
	ew.printf("# HELP go_sched_gomaxprocs_threads The current runtime.GOMAXPROCS setting, or the number of operating system threads that can execute user-level Go code simultaneously. Sourced from /sched/gomaxprocs:threads.\n")
	ew.printf("go_sched_gomaxprocs_threads %d\n", runtime.GOMAXPROCS(0))

	ew.printf("# TYPE go_gc_cycles_automatic_gc_cycles_total counter\n")
	ew.printf("# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime. Sourced from /gc/cycles/automatic:gc-cycles.\n")
	ew.printf("go_gc_cycles_automatic_gc_cycles_total %d\n", rm["/gc/cycles/automatic:gc-cycles"].Uint64())

	ew.printf("# TYPE go_gc_cycles_forced_gc_cycles_total counter\n")
	ew.printf("# HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application. Sourced from /gc/cycles/forced:gc-cycles.\n")
	ew.printf("go_gc_cycles_forced_gc_cycles_total %d\n", rm["/gc/cycles/forced:gc-cycles"].Uint64())

	ew.printf("# TYPE go_gc_cycles_total_gc_cycles_total counter\n")
	ew.printf("# HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles. Sourced from /gc/cycles/total:gc-cycles.\n")
	ew.printf("go_gc_cycles_total_gc_cycles_total %d\n", rm["/gc/cycles/total:gc-cycles"].Uint64())

	ew.printf("# TYPE go_gc_gogc_percent gauge\n")
	ew.printf("# HELP go_gc_gogc_percent Heap size target percentage configured by the user, otherwise 100. This value is set by the GOGC environment variable, and the runtime/debug.SetGCPercent function. Sourced from /gc/gogc:percent.\n")
	ew.printf("go_gc_gogc_percent %d\n", rm["/gc/gogc:percent"].Uint64())

	ew.printf("# TYPE go_gc_gomemlimit_bytes gauge\n")
	ew.printf("# HELP go_gc_gomemlimit_bytes Go runtime memory limit configured by the user, otherwise math.MaxInt64. This value is set by the GOMEMLIMIT environment variable, and the runtime/debug.SetMemoryLimit function. Sourced from /gc/gomemlimit:bytes.\n")
	ew.printf("go_gc_gomemlimit_bytes %d\n", rm["/gc/gomemlimit:bytes"].Uint64())

	ew.printf("# TYPE go_gc_heap_live_bytes gauge\n")
	ew.printf("# HELP go_gc_heap_live_bytes Heap memory occupied by live objects that were marked by the previous GC. Sourced from /gc/heap/live:bytes.\n")
	ew.printf("go_gc_heap_live_bytes %d\n", rm["/gc/heap/live:bytes"].Uint64())

	ew.printf("# TYPE go_gc_heap_tiny_allocs_objects_total counter\n")
	ew.printf("# HELP go_gc_heap_tiny_allocs_objects_total Count of small allocations that are packed together into blocks. These allocations are counted separately from other allocations because each individual allocation is not tracked by the runtime, only their block. Each block is already accounted for in allocs-by-size and frees-by-size. Sourced from /gc/heap/tiny/allocs:objects.\n")
	ew.printf("go_gc_heap_tiny_allocs_objects_total %d\n", rm["/gc/heap/tiny/allocs:objects"].Uint64())

	ew.printf("# TYPE go_gc_limiter_last_enabled_gc_cycle gauge\n")
	ew.printf("# HELP go_gc_limiter_last_enabled_gc_cycle GC cycle the last time the GC CPU limiter was enabled. This metric is useful for diagnosing the root cause of an out-of-memory error, because the limiter trades memory for CPU time when the GC's CPU time gets too high. This is most likely to occur with use of SetMemoryLimit. The first GC cycle is cycle 1, so a value of 0 indicates that it was never enabled. Sourced from /gc/limiter/last-enabled:gc-cycle.\n")
	ew.printf("go_gc_limiter_last_enabled_gc_cycle %d\n", rm["/gc/limiter/last-enabled:gc-cycle"].Uint64())

	ew.printf("# TYPE go_gc_scan_globals_bytes gauge\n")
	ew.printf("# HELP go_gc_scan_globals_bytes The total amount of global variable space that is scannable. Sourced from /gc/scan/globals:bytes.\n")
	ew.printf("go_gc_scan_globals_bytes %d\n", rm["/gc/scan/globals:bytes"].Uint64())

	ew.printf("# TYPE go_gc_scan_heap_bytes gauge\n")
	ew.printf("# HELP go_gc_scan_heap_bytes The total amount of heap space that is scannable. Sourced from /gc/scan/heap:bytes.\n")
	ew.printf("go_gc_scan_heap_bytes %d\n", rm["/gc/scan/heap:bytes"].Uint64())

	ew.printf("# TYPE go_gc_scan_stack_bytes gauge\n")
	ew.printf("# HELP go_gc_scan_stack_bytes The number of bytes of stack that were scanned last GC cycle. Sourced from /gc/scan/stack:bytes.\n")
	ew.printf("go_gc_scan_stack_bytes %d\n", rm["/gc/scan/stack:bytes"].Uint64())

	ew.printf("# TYPE go_gc_scan_total_bytes gauge\n")
	ew.printf("# HELP go_gc_scan_total_bytes The total amount space that is scannable. Sum of all metrics in /gc/scan. Sourced from /gc/scan/total:bytes.\n")
	ew.printf("go_gc_scan_total_bytes %d\n", rm["/gc/scan/total:bytes"].Uint64())

	ew.printf("# TYPE go_gc_stack_starting_size_bytes gauge\n")
	ew.printf("# HELP go_gc_stack_starting_size_bytes The stack size of new goroutines. Sourced from /gc/stack/starting-size:bytes.\n")
	ew.printf("go_gc_stack_starting_size_bytes %d\n", rm["/gc/stack/starting-size:bytes"].Uint64())

	ew.printf("# TYPE go_sync_mutex_wait_total_seconds_total counter\n")
	ew.printf("# HELP go_sync_mutex_wait_total_seconds_total Approximate cumulative time goroutines have spent blocked on a sync.Mutex, sync.RWMutex, or runtime-internal lock. This metric is useful for identifying global changes in lock contention. Collect a mutex or block profile using the runtime/pprof package for more detailed contention data. Sourced from /sync/mutex/wait/total:seconds.\n")
	ew.printf("go_sync_mutex_wait_total_seconds_total %g\n", rm["/sync/mutex/wait/total:seconds"].Float64())
}

func (m *Metrics) writeCardeaMetrics(ew *errWriter) {
	ew.printf("# TYPE cardea_build_info gauge\n")
	ew.printf("# HELP cardea_build_info Build information.\n")
	ew.printf("cardea_build_info{version=%q} 1\n", config.Version)

	ew.printf("# TYPE cardea_start_time_seconds gauge\n")
	ew.printf("# HELP cardea_start_time_seconds Start time of Cardea since unix epoch in seconds.\n")
	ew.printf("cardea_start_time_seconds %g\n", float64(startTime.UnixNano())/1e9)

	ew.printf("# TYPE cardea_connections_active gauge\n")
	ew.printf("# HELP cardea_connections_active Current number of active connections.\n")
	ew.printf("cardea_connections_active %d\n", m.ConnectionsActive.Load())

	ew.printf("# TYPE cardea_connections_total counter\n")
	ew.printf("# HELP cardea_connections_total Total number of connections.\n")
	ew.printf("cardea_connections_total %d\n", m.ConnectionsTotal.Load())

	ew.printf("# TYPE cardea_sessions_active gauge\n")
	ew.printf("# HELP cardea_sessions_active Current number of active sessions.\n")
	ew.printf("cardea_sessions_active %d\n", m.SessionsActive.Load())

	ew.printf("# TYPE cardea_sessions_total counter\n")
	ew.printf("# HELP cardea_sessions_total Total number of sessions.\n")
	ew.printf("cardea_sessions_total %d\n", m.SessionsTotal.Load())

	ew.printf("# TYPE cardea_port_forwards_local_active gauge\n")
	ew.printf("# HELP cardea_port_forwards_local_active Current number of active local port forwards.\n")
	ew.printf("cardea_port_forwards_local_active %d\n", m.PortForwardsLocalActive.Load())

	ew.printf("# TYPE cardea_port_forwards_local_total counter\n")
	ew.printf("# HELP cardea_port_forwards_local_total Total number of local port forwards.\n")
	ew.printf("cardea_port_forwards_local_total %d\n", m.PortForwardsLocalTotal.Load())

	ew.printf("# TYPE cardea_port_forwards_remote_active gauge\n")
	ew.printf("# HELP cardea_port_forwards_remote_active Current number of active remote port forwards.\n")
	ew.printf("cardea_port_forwards_remote_active %d\n", m.PortForwardsRemoteActive.Load())

	ew.printf("# TYPE cardea_port_forwards_remote_total counter\n")
	ew.printf("# HELP cardea_port_forwards_remote_total Total number of remote port forwards.\n")
	ew.printf("cardea_port_forwards_remote_total %d\n", m.PortForwardsRemoteTotal.Load())

	ew.printf("# TYPE cardea_received_bytes_total counter\n")
	ew.printf("# HELP cardea_received_bytes_total Total bytes received from clients.\n")
	ew.printf("cardea_received_bytes_total %d\n", m.ReceivedBytesTotal.Load())

	ew.printf("# TYPE cardea_sent_bytes_total counter\n")
	ew.printf("# HELP cardea_sent_bytes_total Total bytes sent to clients.\n")
	ew.printf("cardea_sent_bytes_total %d\n", m.SentBytesTotal.Load())

	ew.printf("# TYPE cardea_auth_successes_total counter\n")
	ew.printf("# HELP cardea_auth_successes_total Total number of successful authentications.\n")
	ew.printf("cardea_auth_successes_total %d\n", m.AuthSuccessesTotal.Load())

	ew.printf("# TYPE cardea_auth_failures_total counter\n")
	ew.printf("# HELP cardea_auth_failures_total Total number of failed authentications.\n")
	ew.printf("cardea_auth_failures_total{reason=\"unknown_key\"} %d\n", m.AuthFailuresUnknownKeyTotal.Load())
	ew.printf("cardea_auth_failures_total{reason=\"not_yet_valid\"} %d\n", m.AuthFailuresNotYetValidKeyTotal.Load())
	ew.printf("cardea_auth_failures_total{reason=\"no_longer_valid\"} %d\n", m.AuthFailuresNoLongerValidKeyTotal.Load())
	ew.printf("cardea_auth_failures_total{reason=\"denied_source\"} %d\n", m.AuthFailuresDeniedSourceTotal.Load())
	ew.printf("cardea_auth_failures_total{reason=\"denied_backend\"} %d\n", m.AuthFailuresDeniedBackendTotal.Load())
	ew.printf("cardea_auth_failures_total{reason=\"invalid_backend\"} %d\n", m.AuthFailuresInvalidBackendTotal.Load())

	ew.printf("# TYPE cardea_rate_limit_rejections_total counter\n")
	ew.printf("# HELP cardea_rate_limit_rejections_total Total number of rate limit rejections.\n")
	ew.printf("cardea_rate_limit_rejections_total %d\n", m.RateLimitRejectionsTotal.Load())

	ew.printf("# TYPE cardea_backend_errors_total counter\n")
	ew.printf("# HELP cardea_backend_errors_total Total number of backend errors.\n")
	ew.printf("cardea_backend_errors_total{reason=\"timeout\"} %d\n", m.BackendErrorsTimeoutTotal.Load())
	ew.printf("cardea_backend_errors_total{reason=\"refused\"} %d\n", m.BackendErrorsRefusedTotal.Load())
	ew.printf("cardea_backend_errors_total{reason=\"failed_auth\"} %d\n", m.BackendErrorsFailedAuthTotal.Load())
	ew.printf("cardea_backend_errors_total{reason=\"unknown_host\"} %d\n", m.BackendErrorsUnknownHostTotal.Load())
	ew.printf("cardea_backend_errors_total{reason=\"mismatched_hostkey\"} %d\n", m.BackendErrorsMismatchedHostkeyTotal.Load())
	ew.printf("cardea_backend_errors_total{reason=\"other\"} %d\n", m.BackendErrorsOtherTotal.Load())
}
